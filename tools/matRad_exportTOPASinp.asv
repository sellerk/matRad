function PBP = matRad_exportTOPASinp(stf, pln, ct, beamweight, exportbool, MC_scaling, varargin)
% call
%   PBP = matRad_exportTOPASinp(stf, pln, ct, beamweight, exportbool, MC_scaling, filename, pathname)
%
% input
%   stf:           matRad steering information struct
%   pln:           matRad pln struct with meta information
%   ct:            matRad ct struct with meta information
%   beamweight     Voxelweight information (e.g resultGUI.w)
%   exportbool     specify wether output should be created or not
%   MC_scaling     factor to adjust the total number of Ions for the
%                  simulation. run = orig * MC_scaling
%   filename       varargin(1): output filename as string
%   outputdir      varargin(2): output Pathname as string
%
% output
%   PBP:           sorted Struct used to create phys beam plan file
%
%   ToDo:
%   Check if x and Y directions need rotation witch rotation matrix ro be
%   correct
%   Check if multiple Beam export works
%   Check beam  rotations for any direction
%
%
%% check varargin
if nargin <= 6 || isempty(varargin(1))
    exportname = 'Plan_dummyname_';
elseif ~ischar(varargin{1})
    disp('wrong export pathname format, provide string')
    return
else
    exportname = varargin{1};
end

if ~exportbool || nargin < 6 || (nargin == 7 && isempty(varargin(2))) || ~((size(varargin,2) >0) && ~isfolder(varargin(2)))
    exportpath = cd;
else
    exportpath = varargin{2};
end

% check if weight vector is available, either in function call or in stf - otherwise dose calculation not possible
if isempty(beamweight) && ~isfield([stf.ray],'weight')
     error('No weight vector available. Please provide w or add info to stf')
end

% copy bixel weight vector into stf struct
if ~isempty(beamweight)
    if sum([stf.totalNumOfBixels]) ~= numel(beamweight)
        error('weighting does not match steering information')
    end
    counter = 0;
    for i = 1:size(stf,2)
        for j = 1:stf(i).numOfRays
            for k = 1:stf(i).numOfBixelsPerRay(j)
                counter = counter + 1;
                stf(i).ray(j).weight(k) = beamweight(counter);
            end
        end
    end
else % weights need to be in stf!
    beamweight = NaN*ones(sum([stf.totalNumOfBixels]),1);
    counter = 0;
    for i = 1:size(stf,2)
        for j = 1:stf(i).numOfRays
            for k = 1:stf(i).numOfBixelsPerRay(j)
                counter = counter + 1;
                beamweight(counter) = stf(i).ray(j).weight(k);
            end
        end
    end    
end


% Looping over matRad stf Struct needed because Physical Beamplan xml
% needs energy-sorting
for beamcounter = 1 : size(stf,2)
    loopcounter = 1;
    for rayloop = 1 : size(stf(beamcounter).ray,2)
        for bixelloop = 1 : (stf(beamcounter).numOfBixelsPerRay(rayloop))
            PBP_data{beamcounter}(loopcounter,1) = stf(beamcounter).ray(rayloop).rayPos_bev(1); % X-Position
            PBP_data{beamcounter}(loopcounter,2) = stf(beamcounter).ray(rayloop).rayPos_bev(3); % Y-Position
            PBP_data{beamcounter}(loopcounter,3) = beamweight(loopcounter).*1e6; % beamweight
            PBP_data{beamcounter}(loopcounter,4) = stf(beamcounter).ray(rayloop).energy(bixelloop); % energy
            PBP_data{beamcounter}(loopcounter,5) = stf(beamcounter).ray(rayloop).focusFWHM(bixelloop); % FWHM
            pos_x(loopcounter) = stf(beamcounter).ray(rayloop).rayPos_bev(1);
            pos_x(loopcounter) = stf(beamcounter).ray(rayloop).rayPos_bev(3);
            loopcounter = loopcounter+1;
        end
    end
    PBP_help(beamcounter).NumVoxel = loopcounter-1;
end



%% reshape the data into printable format
for beamcounter = 1 : size(stf,2)
    [PBP_help(beamcounter).Energies, ia]= unique(PBP_data{1,beamcounter}(:,4));
    PBP_help(beamcounter).foci = PBP_data{1,beamcounter}(ia,5);
    for IESloop = 1 : numel(PBP_help(beamcounter).Energies)
        PBP.IES(IESloop).energy =  PBP_help(beamcounter).Energies(IESloop);
        PBP.IES(IESloop).focus =   PBP_help(beamcounter).foci(IESloop);
        PBP.IES(IESloop).data{:,1} = PBP_data{1,beamcounter}((PBP_data{1,beamcounter}(:,4) ==  PBP_help(beamcounter).Energies(IESloop)),1); % X-Position
        PBP.IES(IESloop).data{:,2} = PBP_data{1,beamcounter}((PBP_data{1,beamcounter}(:,4) ==  PBP_help(beamcounter).Energies(IESloop)),2); % Y-Position
        PBP.IES(IESloop).data{:,3} = PBP_data{1,beamcounter}((PBP_data{1,beamcounter}(:,4) ==  PBP_help(beamcounter).Energies(IESloop)),3); % beamweight
        PBP_help(beamcounter).PBP_x{IESloop}(:,1) = PBP_data{1,beamcounter}((PBP_data{1,beamcounter}(:,4) ==  PBP_help(beamcounter).Energies(IESloop)),1);
        PBP_help(beamcounter).PBP_y{IESloop}(:,1) = PBP_data{1,beamcounter}((PBP_data{1,beamcounter}(:,4) ==  PBP_help(beamcounter).Energies(IESloop)),2);
        PBP_help(beamcounter).PBP_partcount{IESloop}(:,1) = PBP_data{1,beamcounter}((PBP_data{1,beamcounter}(:,4) ==  PBP_help(beamcounter).Energies(IESloop)),3);
        PBP.IES(IESloop).data =  cell2mat(PBP.IES(IESloop).data);
    end
    PBP_help(beamcounter).NumIES = IESloop;
    %% weight applied to each voxel to adapt number of particles used for simulation
    disp(['Total Number of Ions used: ', num2str(sum(PBP_data{1,1}(:,3))*MC_scaling)])
    %% calculation of beamspread
    Erange = [115,  115.8, 121.6,   122.3, 126.0, 131.5, 136.9,  137.4,  138.0, 138.6, 186.8, 187.3, 188.7, 209.2, 209.8, 217.4, 219.5, 219.9];
    Spread = [0.001,  0.1,   0.125,   0.15,  0.2,   0.5,   0.75,   0.77,   0.7,   0.8,   1.,   0.95,   0.9,   0.85,  0.9,   0.95,  1.,    1.1];
    beamspread = interp1(Erange,Spread,PBP_help.Energies, 'nearest', 'extrap');
    %% Calculation of Iso
    % Bestimmung der Mitte des CTs   
    Snout = 1119;
    IsoCTX = size(ct.x,2)/2+ct.x(1);
    IsoCTY = size(ct.y,2)/2+ct.y(1); 
    IsoCTZ = size(ct.z,2)/2+ct.z(1);
    IsoCT= [IsoCTX, IsoCTY, IsoCTZ];
    IsoBeam = (stf.isoCenter + ct.dicomMeta.ImagePositionPatient')-1;
    Iso = IsoBeam - IsoCT;
    finalIsoX = Iso(2);
    finalIsoY = Iso(3)*-1;
    finalIsoZ = Iso(1)-Snout;
    % check these for any Beampos
    RotationX = -90;
    RotationY = 0;
    RotationZ = 90;
    a = stf.gantryAngle
    g = a;
    t = stf.couchAngle
    x = (round(rad2deg(arctan(sin(t)*tan(g)+tan(a)*cos(t)/cos(g))),2))
    y = (round(rad2deg((arcsin(sin(g)*cos(a)*cos(t)+sin(a)*sin(t)))),2))
    z = (round(rad2deg(arctan(sin(a)*tan(g)+tan(t)*cos(a)/cos(g))),2))
    %% calculation of dosegrid and bins
    XBins= round(ct.cubeDim(1)/2);
    YBins= round(ct.cubeDim(2)/2);
    ZBins= round(ct.cubeDim(3)/4);
    HLX=  (ct.cubeDim(1)*ct.resolution.x)/20;
    HLY= (ct.cubeDim(2)*ct.resolution.y)/20;
    HLZ= (ct.cubeDim(3)*ct.resolution.z)/20;
    
    %% export 
    if exportbool
                print_times_point = [sprintf('%.d ', PBP_help.NumVoxel), sprintf('%.d ', (1:PBP_help.NumVoxel))];
                print_times_beams = [sprintf('%.d ',ones(size(stf,2))), sprintf('%.d',ones(size(stf,2)).*PBP_help(beamcounter).NumVoxel), ' s', newline];
                print_physics = [...
                    '#============================================================================##', newline ...
                    '--- Physics' , newline ...
                    '#============================================================================#', newline ...
                    'i:Ts/NumberOfThreads = 0', newline ...
                    'i:Ts/Seed = 10', newline, newline];
                print_energies = [...
                    '#============================================================================##', newline ...
                    '--- Sequential Time Mode', newline ...
                    '#============================================================================#', newline, newline ...
                    's:Tf/Energies/Function  = "Step"', newline ...
                    'dv:Tf/Energies/Times    = ', sprintf('%.d ',size(PBP_help.Energies,1)), sprintf('%.d ',cumsum(cell2mat(cellfun(@numel, PBP_help(1).PBP_x, 'UniformOutput', false)))), 's', newline ...
                    'dv:Tf/Energies/Values   = ', sprintf('%.d ',size(PBP_help.Energies,1)), sprintf('%.12g ', PBP_help.Energies'.*1.0072765), 'MeV', newline];
                print_particles = ['s:Tf/Particles/Function = "Step"', newline ...
                    'dv:Tf/Particles/Times   = ', print_times_point, 's', newline ...
                    'iv:Tf/Particles/Values  = ', sprintf('%.d ',PBP_help.NumVoxel), sprintf('%.f ', round(vertcat(PBP_help(beamcounter).PBP_partcount{1,:})'.*MC_scaling,0)), newline];
                print_positionsX = ['s:Tf/PositionsX/Function = "Step"', newline ...
                    'dv:Tf/PositionsX/Times   = ', print_times_point, 's', newline ...
                    'dv:Tf/PositionsX/Values  = ', sprintf('%.d ',PBP_help.NumVoxel),  sprintf('%.12g ',vertcat(PBP_help(beamcounter).PBP_y{1,:})'*-1), 'mm', newline]; 
                print_positionsY = ['s:Tf/PositionsY/Function = "Step"', newline ...
                    'dv:Tf/PositionsY/Times   = ', print_times_point, 's', newline ...
                    'dv:Tf/PositionsY/Values  = ', sprintf('%.d ',PBP_help.NumVoxel), sprintf('%.12g ',vertcat(PBP_help(beamcounter).PBP_x{1,:})'*-1), 'mm', newline]; 
                print_RotationX = ['s:Tf/RotationX/Function = "Step"', newline ...
                    'dv:Tf/RotationX/Times   = ', print_times_beams ...
                    'dv:Tf/RotationX/Values  = ', sprintf('%.d ',ones(size(stf,2))), sprintf('%.f ',RotationX), 'deg', newline];
                print_RotationY =  ['s:Tf/RotationY/Function = "Step"', newline ...
                    'dv:Tf/RotationY/Times   = ', print_times_beams ...
                    'dv:Tf/RotationY/Values  = ', sprintf('%.d ',ones(size(stf,2))), sprintf('%.f ',RotationY), 'deg', newline];
                print_RotationZ =  ['s:Tf/RotationZ/Function = "Step"', newline ...
                    'dv:Tf/RotationZ/Times   = ', print_times_beams ...
                    'dv:Tf/RotationZ/Values  = ', sprintf('%.d ',ones(size(stf,2))), sprintf('%.f ',RotationZ), 'deg', newline];
                print_ISOX = ['s:Tf/IsoX/Function = "Step" ', newline ...
                    'dv:Tf/IsoX/Times   = ', print_times_beams ...
                    'dv:Tf/IsoX/Values  = ', sprintf('%.d ',ones(size(stf,2))), sprintf('%.f ',finalIsoX), 'mm', newline];
                print_ISOY = ['s:Tf/IsoY/Function = "Step" ', newline ...
                    'dv:Tf/IsoY/Times   = ', print_times_beams ...
                    'dv:Tf/IsoY/Values  = ', sprintf('%.d ',ones(size(stf,2))), sprintf('%.f ',finalIsoY), 'mm', newline];
                print_ISOZ = ['s:Tf/IsoZ/Function = "Step" ', newline ...
                    'dv:Tf/IsoZ/Times   = ', print_times_beams ...
                    'dv:Tf/IsoZ/Values  = ', sprintf('%.d ',ones(size(stf,2))), sprintf('%.f ',finalIsoZ), 'mm', newline];
                print_spread = ['s:Tf/Spread/Function  = "Step"', newline ...
                    'dv:Tf/Spread/Times    = ', sprintf('%.d ',size(PBP_help.Energies,1)), sprintf('%.d ',cumsum(cell2mat(cellfun(@numel, PBP_help(1).PBP_x, 'UniformOutput', false)))), 's', newline ...
                    'dv:Tf/Spread/Values   = ', sprintf('%.d ',size(PBP_help.Energies,1)), sprintf('%.5g ',beamspread'), 'mm', newline];
                print_time = ['d:Tf/TimelineStart  = 0.0 s', newline ...
                    'd:Tf/TimelineEnd    = ', sprintf('%.d ',PBP_help.NumVoxel), 's', newline ...
                    'i:Tf/NumberOfSequentialTimes = ', sprintf('%.d ',PBP_help.NumVoxel), newline, newline];
               
                print_materials = [...
                    '#============================================================================##', newline ...
                    '--- Materials', newline ...
                    '#============================================================================#', newline, newline ...
                    'sv:Ma/Tungsten/Components=1 "Tungsten"', newline ...
                    'uv:Ma/Tungsten/Fractions=1 1', newline ...
                    'd:Ma/Tungsten/Density=19.25 g/cm3', newline ...
                    'sv:Ma/Nickel/Components=1 "Nickel"', newline ...
                    'uv:Ma/Nickel/Fractions=1 1', newline ...
                    'd:Ma/Nickel/Density=8.908 g/cm3', newline ...
                    'sv:Ma/Air/Components=4 "Carbon" "Nitrogen" "Oxygen" "Argon"', newline ...
                    'uv:Ma/Air/Fractions=4 0.000124 0.755268 0.231781 0.012827', newline ...
                    'd:Ma/Air/Density=1.20484 mg/cm3', newline ...
                    'd:Ma/Air/MeanExcitationEnergy=85.7 eV', newline ...
                    'sv:Ma/DetecGas/Components=3 "Carbon" "Oxygen" "Argon"', newline ...
                    'uv:Ma/DetecGas/Fractions=3 0.05924 0.15796 0.7828', newline ...
                    'd:Ma/DetecGas/Density=1.8232 mg/cm3', newline ...
                    's:Ma/DetecGas/DefaultColor="lightblue"', newline ...
                    'sv:Ma/NiPETMix/Components=4 "Hydrogen" "Carbon" "Oxygen" "Nickel"', newline ...
                    'uv:Ma/NiPETMix/Fractions=4 0.0239172 0.35625912 0.18982368 0.43', newline ...
                    'd:Ma/NiPETMix/Density=2.2 g/cm3', newline ...
                    's:Ma/NiPETMix/DefaultColor="yellow"', newline ...
                    'sv:Ma/PET/Components=3 "Hydrogen" "Carbon" "Oxygen" ', newline ...
                    'uv:Ma/PET/Fractions=3 0.04167 0.62501 0.33332', newline ...
                    'd:Ma/PET/Density=1.38 g/cm3', newline ...
                    's:Ma/PET/DefaultColor="blue"', newline ...
                    'sv:Ma/RiFiMat/Components=3 "Hydrogen" "Carbon" "Oxygen" ', newline ...
                    'uv:Ma/RiFiMat/Fractions=3 0.07058 0.74118 0.18824', newline ...
                    'd:Ma/RiFiMat/Density=1.218 g/cm3', newline ...
                    's:Ma/RiFiMat/DefaultColor="red"', newline ...
                    'sv:Ma/Mylar/Components=3 "Hydrogen" "Carbon" "Oxygen" ', newline ...
                    'uv:Ma/Mylar/Fractions=3 0.04167 0.625 0.33333', newline ...
                    'd:Ma/Mylar/Density=1.4 g/cm3', newline ...
                    's:Ma/Mylar/DefaultColor="green"', newline ...
                    'sv:Ma/Kevlar/Components=4 "Hydrogen" "Carbon" "Nitrogen" "Oxygen" ', newline ...
                    'uv:Ma/Kevlar/Fractions=4 0.05785 0.69422 0.1157 0.13223', newline ...
                    'd:Ma/Kevlar/Density=1.45 g/cm3', newline ...
                    's:Ma/Kevlar/DefaultColor="blue"', newline, newline];
            
                print_assign_particle = [...
                    '#============================================================================##', newline ...
                    '--- Assign Particles', newline ...
                    '#============================================================================#', newline, newline ...
                    's:So/Example/Type                     = "Beam"', newline ...
                    's:So/Example/Component                = "BeamPosition"', newline ...
                    's:So/Example/BeamParticle             = "proton"', newline ...
                    'u:So/Example/BeamEnergySpread         = 0 ', newline ...
                    's:So/Example/BeamPositionDistribution = "Gaussian"', newline ...
                    's:So/Example/BeamPositionCutoffShape  = "Ellipse"', newline ...
                    'd:So/Example/BeamPositionCutoffX      = 10. cm', newline ...
                    'd:So/Example/BeamPositionCutoffY      = 10. cm', newline ...
                    'd:So/Example/BeamPositionSpreadX      = Tf/Spread/Value mm', newline ...
                    'd:So/Example/BeamPositionSpreadY      = Tf/Spread/Value mm', newline ...
                    's:So/Example/BeamAngularDistribution  = "None"', newline ...
                    'i:So/Example/NumberOfHistoriesInRun = Tf/Particles/Value', newline ...
                    'd:So/Example/BeamEnergy = Tf/Energies/Value MeV', newline ...
                    'd:Ge/BeamPosition/TransZ = -78.12 cm', newline ...
                    'd:Ge/BeamPosition/TransX = 1. * Tf/PositionsX/Value mm' newline ...
                    'd:Ge/BeamPosition/TransY = 1. * Tf/PositionsY/Value mm' newline ...
                    'd:Ge/BeamPosition/RotX=0. deg', newline ...
                    'd:Ge/BeamPosition/RotY=0. deg', newline ...
                    'd:Ge/BeamPosition/RotZ=0. deg', newline ...
                    'includeFile=Exit_Window.txt', newline ...
                    'includeFile=MW_Foils_homogeneous_MultiWires.txt', newline ...
                    'includeFile=IC_Foils_homogeneous.txt', newline, newline];
                
                print_geometries =[...
                    '#============================================================================##', newline ...
                    '--- Geometries', newline ...
                    '#============================================================================#', newline, newline ...
                    's:Ge/World/Material  = "Air"', newline ...
                    'd:Ge/World/HLX       = 2.0 m', newline ...
                    'd:Ge/World/HLY       = 2.0 m', newline ...
                    'd:Ge/World/HLZ       = 2.0 m', newline ...
                    'b:Ge/World/Invisible = "True"', newline ...
                    'includeFile = HUtoMaterial_Modulation_Patient.txt', newline ...
                    's:Ge/Patient/Parent         = "World"', newline ...
                    's:Ge/Patient/Material       = "G4_WATER"', newline ...
                    'd:Ge/Patient/TransX         = -1. * Tf/IsoX/Value mm', newline ...
                    'd:Ge/Patient/TransY         = -1. * Tf/IsoY/Value mm', newline ...
                    'd:Ge/Patient/TransZ         = -1. * Tf/IsoZ/Value mm', newline ...
                    'd:Ge/Patient/RotX           = Tf/RotationX/Value deg', newline ...
                    'd:Ge/Patient/RotZ           = Tf/RotationZ/Value deg', newline ...
                    'd:Ge/Patient/RotY           = Tf/RotationY/Value deg', newline ...
                    's:Ge/Patient/Type           = "TsDicomPatient"', newline ...
                    's:Ge/Patient/DicomDirectory = "dicom"', newline ...
                    's:Ge/Patient/AssignToRegionNamed = "Inpatient"', newline, newline];
                
                print_scoring = [...
                    '#============================================================================##', newline ...
                    '--- Scoring', newline ...
                    '#============================================================================#', newline, newline ...
                    's:Ge/dosegrid/Type       = "TsBox"', newline ...
                    's:Ge/dosegrid/Parent     = "Patient"', newline ...
                    'd:Ge/dosegrid/HLX       = ', sprintf('%g ', HLX), 'cm', newline ...
                    'd:Ge/dosegrid/HLY       = ', sprintf('%g ', HLY), 'cm', newline ...
                    'd:Ge/dosegrid/HLZ       = ', sprintf('%g ', HLZ), 'cm', newline ...
                    'd:Ge/dosegrid/TransX     = 0. cm', newline ...
                    'd:Ge/dosegrid/TransY     = 0. cm', newline ...
                    'd:Ge/dosegrid/TransZ     = 0 cm', newline ...
                    'd:Ge/dosegrid/RotX       = 0. deg', newline ...
                    'd:Ge/dosegrid/RotY       = 0 deg', newline ...
                    'd:Ge/dosegrid/RotZ       = 0. deg', newline ...
                    'i:Ge/dosegrid/XBins      = ', sprintf('%d', XBins), newline ...
                    'i:Ge/dosegrid/YBins      = ', sprintf('%d', YBins), newline ...
                    'i:Ge/dosegrid/ZBins      = ', sprintf('%d', ZBins), newline ...
                    'b:Ge/dosegrid/IsParallel = "T"', newline ...
                    's:Sc/dose2/Quantity                  = "DoseToWater"', newline ...
                    's:Sc/dose2/Component                 = "dosegrid"', newline ...
                    's:Sc/dose2/OutputFile                = "Dose2Water"', newline ...
                    's:Sc/dose2/OutputType                = "Dicom"', newline ...
                    'b:Sc/dose2/OutputToConsole           = "F"', newline ...
                    'b:Sc/dose2/Visualize                 = "F"', newline ...
                    'b:Sc/dose2/PreCalculateStoppingPowerRatios = "True"', newline ...
                    's:Sc/dose2/IfOutputFileAlreadyExists = "Overwrite"', newline ...
                    'b:Sc/dose2/DICOMOutput32BitsPerPixel = "True"', newline, newline...
                    'b:Ts/ShowCPUTime                = "tRuE" ', newline ...
                    'i:Ts/ShowHistoryCountAtInterval = 10000', newline ...
                    'b:Ge/CheckForOverlaps = "t"', newline ...
                    'b:Ge/CheckForUnusedComponents = "f"  ', newline ];

                fid_PBP = fopen([exportpath filesep exportname, '.topasinp'], 'w');
                fprintf(fid_PBP,[print_physics, print_energies, print_particles, print_positionsX,print_positionsY, print_RotationX, print_RotationY,print_RotationZ, print_ISOX, print_ISOY, print_ISOZ, print_spread, print_time, print_materials, print_assign_particle, print_geometries, print_scoring]);
                fclose(fid_PBP);
                
end
PBP(beamcounter).Allpoints = cell2mat(PBP_data);

end

